#!/usr/bin/env bash
##Created by Edward "edge226" Tunnah.

## Checks the depends of a program and writes it to /tmp/lbf/ in a
## directory structure.



## unset possibly use variables.
unset pkgname depends makedepends checkdepends optdepends origin tmpdir origin_pass origin_set origin_list

source /home/edge226/github/lucid/conf/lbf.vars ## This allows for the
	## usage of scanning an array of parameters to track in lbf.vars

## imported this to set gitrepodir.
source /home/edge226/github/lucid/conf/lbf.conf
run_again="/home/edge226/github/lucid/bin/checkdeps"
#recurse="/home/edge226/github/lucid/bin/recursedeps"

unset searchdir
origin=""
OPTIND=1 ## make sure the optargs are reset for getopts

while getopts "t:f:n:o:s:rivph" opt; do  ## Standard getopts while loops for
							   ## dealing with options.
	case "$opt" in
		v)  verbose="yes";;
		p)  pretend="yes"
			verbose="yes";;
		n)  name=$OPTARG;;
		t)	tmpdir=$OPTARG;;
		o)  origin_tmpdir=$OPTARG;;
		f)  origin_file=$OPTARG;;
		s)  suborigin_file=$OPTARG;;
		i)	info="yes";;
		r)  recursive="yes";;
		h)  printf '%s\n' "$checkdeps_usage"; exit 0;;
		\?) printf '%s\n' "$checkdeps_usage" >&2; exit 1;;
	esac
done

check_name_set() {
	empty_name="1"
	for var in "${checkdeps_vars[@]}"; do
		typeset -n local ref="$var"
		if [[ ! "$ref" = "no" ]] && [[ ! "$ref" = "yes" ]]; then 
			#printf '\n%s %s\n' "Calculating variables:" "$ref"
			if [[ "$ref" = "" ]] && [[ ! "$empty_name" = "0" ]]; then
				#printf "Setting empty_name to 1\n"
				empty_name="1"
			elif [[ ! "$ref" = "" ]] && [[ "$ref" = "$name" ]]; then
				#printf "Setting empty_name to 0\n"
				empty_name="0"
			fi
		fi
	done
}

set_params() {
	check_name_set
	if [[ "$empty_name" = "1" ]] ; then
		printf "Please enter a name to start the search: "
		read name
		if [[ "$recursive" = "" ]] ; then
			while [[ "$recursive" = "" ]] || [[ ! "$recursive" = "yes" ]] || [[ ! "$recursive" = "no" ]]; do
				printf "Would you like to run recursively? (yes/No) "
				read recursive
				if [[ "$recursive" = "" ]] ; then
					recursive="no"
				fi
				if [[ "$recursive" = "yes" ]] || [[ "$recursive" = "no" ]] ; then
					break
				fi
			done
		fi
	fi
	
	if [[ ! "$name" = "" ]]; then
		if [[ "$tmpdir" = "/tmp/lbf" ]]; then
			if [[ "$info" != "yes" ]] ; then
				if [[ "$origin_file" = "" ]]; then
					origin_file="$tmpdir/origin"
				fi
				if [[ "$suborigin_file" = "" ]]; then
					suborigin_file="$tmpdir/suborigin"
				fi
				tmpdir="$tmpdir/$name"
				origin_tmpdir="$tmpdir"
			fi
		fi
		if [[ "$searchdir" = "" ]]; then
			searchdir=$( find "$gitrepodir" -name "$name" -type d -print0 )
			#printf '\n%s %s\n' "Setting searchdir to:" "$searchdir"
		fi	
	fi

	if [[ ! "$searchdir" = "" ]]; then
		#printf '\n%s %s\n' "Going into searchdir:" "$searchdir"
		if [[ -d "$searchdir" ]]; then
			cd "$searchdir" || exit
		fi
		#printf '\ntmpdir is %s\n' "$tmpdir"
		if [[ -f ./PKGBUILD ]]; then
			source ./PKGBUILD
		elif [[ ! -f ./PKGBUILD ]]; then 
			printf '%s\n' "This PKGBUILD file does not exist."
			printf '%s\n' "$checkdeps_usage" >&2; exit 1
		fi
		if [[ "$origin" = "" ]]; then
			for pkg in "${pkgname[@]}"; do
				if [[ "$pkg" = "$name" ]]; then
					origin="$pkg"
					provides+=( "$pkg" )
				elif [[ "$pkg" = "$name" ]] || [[ ! "$pkg" = "$name" ]] ; then
					provides+=( "$pkg" )
				fi
			done
			#printf '\n%s\n' "privides is set to:"
			#printf '%s\n' "${provides[@]}"
		fi
		if [[ "$origin_list_file" = "" ]] ; then
			origin_list_file="$tmpdir/origin_list"
			#printf '\n%s %s\n' "origin_list_file set to:" "$origin_list_file"
		fi
		if [[ "$provides_file" = "" ]] ; then
			provides_file="$tmpdir/provides"
		fi
		if [[ "$repo_file" = "" ]] ; then
			repo_file="$tmpdir/repo"			
		fi
	elif [[ "$searchdir" = "" ]] ; then
		exit 1
	fi
}

check_todo(){ ## checks if the file has already been scanned or not.
	local check_match="$1"
	local check_file="$2"
	match="0"
	if [[ -f "$check_file" ]] ; then
		while IFS= read -r line; do
			if [[ "$line" = "$check_match" ]]; then
				match="1"
			elif [[ ! "$line" = "$check_match" ]]; then
				if [[ ! "$match" = "1" ]]; then
					match="0"
				fi
			fi
		done < "$check_file"
	fi
	#printf '\n%s %s%s %s\n' "This is the check done status for" "$check_match" ":" "$match"
	#read
}

write_provides(){ ## writes the package names that the pkgbuild compile will provide. 
	for pkg in "${provides[@]}"; do
		if [[ ! "$pkg" = "" ]]; then
			printf '%s\n' "$pkg" >> "$provides_file"
			printf '%s\n' "$pkg" >> "$origin_file"
		fi
	done
}

get_repo() { ## removes the program name, forward slashes and prefix of the repository name.
	repo="$searchdir"
	repo=${repo%%"/$origin"}
	repo=${repo##*/}
}

## Sets the origin name. This is important for dealing with nested
## iterations of this program.
create_origins() { ## creates an origin set that gathers data used in nesting.
	#printf '\n%s\n' "Running create_origins: "
	unset depbase depname
	#printf '\n%s %s\n' "tmpdir set to:" "$tmpdir"
		
		check_todo "$origin" "$origin_file"
		if [[ "$match" = "0" ]] ; then
			if [[ ! -d "$tmpdir" ]]; then
				#printf '\n%s %s\n' "creating tmpdir directory:" "$tmpdir"
				mkdir -p "$tmpdir"
				#read
			fi
		fi
		get_repo
		if [[ ! -f "$repo_file" ]]; then
			printf '%s\n' "$repo" > "$repo_file"
		fi
		if [[ ! -f "$origin_file" ]]; then
			if [[ ! "$origin" = "" ]]; then
				touch "$origin_file"
				write_provides
			fi
		elif [[ -f "$origin_file" ]]; then
			if [[ "$match" = "0" ]] && [[ ! "$origin" = "" ]]; then
				write_provides
			fi
		fi
		if [[ ! -f "$suborigin_file" ]]; then
			#printf '\n%s %s\n' "suborigin_file is set to:" "$suborigin_file"
			printf '%s\n' "$origin" > "$suborigin_file"
		fi
		if [[ ! -f "$origin_list_file" ]] && [[ ! -f "$origin_list_file_old" ]]; then
			for depbase in "${checkdeps_pkgbuild_array[@]}"; do	## allows us a start with all the dependency base names as defined in lbf.vars
				if [[ "$i" = "" ]] ; then
					local i=0
				fi
				typeset -n local ref="$depbase" ## this allows the proceeding for loop
										## to activate correctly.
				
				for dep in "${ref[@]}"; do ## sets origin_set.
					local depname=${dep%%[<>=]*}
					find_nextsearchdir "$depname"
					if [[ ! "$depname" = "" ]] && [[ "$nosearchdir" = "0" ]]; then
						check_todo "$depname" "$suborigin_file"
						if [[ "$match" = "0" ]]; then
							printf '%s\n' "$depname" >> "$origin_list_file"
							printf '%s\n' "$depname" >> "$suborigin_file"
							#printf '\n%s %s\n' "Creating directory:" "$tmpdir/$depbase/$depname"
							mkdir -p "$tmpdir/$depbase/$depname"
							#read
						fi
					fi
					printf '%s\n' "$depname" >> "$tmpdir/${checkdeps_array[$i]}"
				done
				i="$i"+1
			done
		fi
}

find_origin_lists() {
	origin_lists=( $( find "$origin_tmpdir" -name origin_list -type f -print ) )
}

find_nextsearchdir() {
	name="$1"
	local nextsearchdir=$( find "$gitrepodir" -name "$name" -type d -print0 )
	nosearchdir="0"
	if [[ "$nextsearchdir" = "" ]]; then
		nosearchdir="1"
	fi
}

recurse() {
	while find_origin_lists; do
		find_origin_lists
		if [[ "$origin_lists" = "" ]]; then
			break
		fi
		for origin_list_file in "${origin_lists[@]}"; do
			if [[ -f "$origin_list_file" ]]; then
				while IFS= read -r dep; do
					if [[ ! "$dep" = "" ]]; then
						check_todo "$dep" "$origin_file"
						if [[ "$match" = "0" ]]; then
							tmpdir=$( find "$origin_tmpdir" -name "$dep" -type d -print0 )
							#printf '\n sending tmpdir as searched from origin_tmpdir as searched from %s: \n%s\n%s\n' "$dep" "$tmpdir" "$origin_tmpdir"
							run_again_opts=( "-n" "$dep" "-t" "$tmpdir" "-f" "$origin_file" "-o" "$origin_tmpdir" "-s" "$suborigin_file" )
							"$run_again" "${run_again_opts[@]}"
						fi
					fi				
				done < "$origin_list_file"
				if [[ "$origin_list_old" = "" ]] ; then
					printf '\n%s\n' "Doing a recursive scan ... This may take a while."
				fi
				local origin_list_old="$origin_list_file""_old"
				#printf '\n%s %s %s %s\n' "Moving origin_list:" "$origin_list_file" "to" "$origin_list_old"
				#read
				mv_opts=( "$origin_list_file" "$origin_list_old" ) ## Moving the origin_list to another file allows to check
				mv "${mv_opts[@]}" ## whether the check has been done before or not.
			fi
		done
	done
}

give_info() {
	local info_dir=$( find "$tmpdir" -name "$name" -type d -print0 )
	#if [[ "$debug" = "yes" ]] ; then
		##printf '\n%s %s\n' "info_dir equals" "$info_dir"
	#fi
	cd "$info_dir" || exit
	for file in *; do
		if [[ ! -d "$file" ]] ; then
			if [[ "$file" != "origin_list_old" ]] ; then
				if [[ "$file" != "origin" ]] ; then
					if [[ "$file" != "suborigin" ]]; then
						printf '\n%s: %s\n' "Printing out information for" "$file"
						cat "$file"
					fi
				fi
			fi
		fi
	done
}

set_params

if [[ "$info" != "yes" ]] ; then
	create_origins
	if [[ "$recursive" = "yes" ]] ; then
		recurse
	fi
fi
if [[ "$info" = "yes" ]] ; then
	give_info
fi
exit 0
