#!/usr/bin/env bash
##Created by Edward "edge226" Tunnah.

## Checks the depends of a program and writes it to /tmp/lbf/ in a
## directory structure.



## unset possibly use variables.
unset pkgname depends makedepends checkdepends optdepends origin tmpdir origin_pass origin_set origin_list

source /home/edge226/github/lucid/conf/lbf.vars ## This allows for the
	## usage of scanning an array of parameters to track in lbf.vars

## imported this to set gitrepodir.
source /home/edge226/github/lucid/conf/lbf.conf
run_again="/home/edge226/github/lucid/bin/checkdeps"
#recurse="/home/edge226/github/lucid/bin/recursedeps"

unset searchdir
origin=""
OPTIND=1 ## make sure the optargs are reset for getopts

while getopts "t:f:n:o:s:rvph" opt; do  ## Standard getopts while loops for
							   ## dealing with options.
	case "$opt" in
		v)  verbose="yes";;
		p)  pretend="yes"
			verbose="yes";;
		n)  name=$OPTARG;;
		t)	tmpdir=$OPTARG;;
		o)  origin_tmpdir=$OPTARG;;
		f)  origin_file=$OPTARG;;
		s)  suborigin_file=$OPTARG;;
		r)  recursive="yes";;
		h)  printf '%s\n' "$checkdeps_usage"; exit 0;;
		\?) printf '%s\n' "$checkdeps_usage" >&2; exit 1;;
	esac
done

set_params() {
	if [ ! "$name" = "" ]; then
		if [ "$tmpdir" = "/tmp/lbf" ]; then
			tmpdir="$tmpdir/$name"
			origin_tmpdir="$tmpdir"
			printf '\n%s %s\n' "tmpdir set to:" "$tmpdir"
			if [ ! -d "$tmpdir" ]; then
				printf '\n%s %s\n' "creating tmpdir directory:" "$tmpdir"
				mkdir -p "$tmpdir"
				#read
			fi
		fi
		if [ "$searchdir" = "" ]; then
			searchdir=$( find "$gitrepodir" -name "$name" -type d -print0 )
			printf '\n%s %s\n' "Setting searchdir to:" "$searchdir"
		fi	
	fi

	if [ ! "$searchdir" = "" ]; then
		printf '\n%s %s\n' "Going into searchdir:" "$searchdir"
		cd "$searchdir"
		printf '\ntmpdir is %s\n' "$tmpdir"
		source PKGBUILD
		if [ "$origin" = "" ]; then
			origin="$pkgname"
		fi
		if [ "$origin_file" = "" ]; then
			origin_file="$tmpdir/origin"
		fi
		if [ "$origin_list_file" = "" ]; then
			origin_list_file="$tmpdir/origin_list"
		fi
		if [ "$suborigin_file" = "" ]; then
			suborigin_file="$tmpdir/suborigin"
		fi
		if [ "$origin_lists" = "" ]; then
			origin_lists="$tmpdir/origin_lists" 
		fi
	fi
}

check_todo(){ ## checks if the file has already been scanned or not.
	check_match="$1"
	check_file="$2"
	match="0"
	for line in $( cat "$check_file" ); do
		if [ "$line" = "$check_match" ]; then
			match="1"
		elif [ ! "$line" = "$check_match" ]; then
			if [ ! "$match" = "1" ]; then
				match="0"
			fi
		fi
	done
	printf '\n%s %s%s %s\n' "This is the check done status for" "$check_match" ":" "$match"
	#read
}

## Sets the origin name. This is important for dealing with nested
## iterations of this program.
create_origins() { ## creates an origin set that gathers data used in nesting.
	printf '\n%s\n' "Running create_origins: "
	unset depbase depname
	if [ ! -f "$origin_file" ]; then
		touch "$origin_file"
		printf '%s\n' "$origin" > "$origin_file"
	elif [ -f "$origin_file" ]; then
			printf '%s\n' "$origin" >> "$origin_file"
	fi
	if [ ! -f "$suborigin_file" ]; then
		printf '%s\n' "$origin" > "$suborigin_file"
	fi
	if [ ! -f "$origin_list_file" ]; then
		for depbase in "${checkdeps_array[@]}"; do	## allows us a start with all the dependency base names as defined in lbf.vars
			typeset -n ref="$depbase" ## this allows the proceeding for loop
									## to activate correctly.
			
			for dep in "${ref[@]}"; do ## sets origin_set.
				depname=${dep%%[<>=]*}
				if [ ! "$depname" = "" ]; then
					check_todo "$depname" "$suborigin_file"
					if [ "$match" = "0" ]; then
						printf '%s\n' "$depname" >> "$origin_list_file"
						printf '%s\n' "$depname" >> "$suborigin_file"
						printf '\n%s %s\n' "Creating directory:" "$tmpdir/$depbase/$depname"
						mkdir -p "$tmpdir/$depbase/$depname"
						#read
					fi
				fi
			done
		done
	fi
}

find_origin_lists() {
	find "$origin_tmpdir" -name origin_list -type f -fprint0
}

recurse() {
	unset -n depname
	if [ -f "$origin_list_file" ]; then
		for dep in $( cat "$origin_list_file" ); do
			check_todo "$dep" "$origin_file"
			if [ "$match" = "0" ]; then
				tmpdir=$( find "$origin_tmpdir" -name "$dep" -type d -print0 )
				printf '\n sending tmpdir as searched from origin_tmpdir: \n%s\n%s\n' "$tmpdir" "$origin_tmpdir"
				run_again_opts=( "-n" "$dep" "-t" "$tmpdir" "-f" "$origin_file" "-o" "$origin_tmpdir" "-s" "$suborigin_file" )
				"$run_again" "${run_again_opts[@]}"
			fi
		done
	fi
}

#recurse_origin_list() {
	#printf '\n%s %s\n' "origin is" "$origin"
	#for dep in $( cat "$tmpdir/origin_list" ); do
		#unset next_pkgbuild
		###"$run_again" -rv -o "$origin_pass" -t "/tmp/lbf/$origin_pass"
		##"$run_again" -v -t "$next_path" -s "$next_pkgbuild"
	#done
#}

set_params
find_origin_lists
#create_origins

#if [ "$recursive" = "yes" ]; then
#	recurse
#fi

exit 0
